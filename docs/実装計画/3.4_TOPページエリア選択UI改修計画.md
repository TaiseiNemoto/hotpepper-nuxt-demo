# TOPページ エリア選択UI改修 - 実装計画

## 概要

TOPページのエリア選択UIを段階的なデータ取得方式に変更します。親子関係の自動補完機能を廃止し、ユーザーが明示的にエリアを選択する方式に変更します。

**データ取得の最適化**:

- 内部API（`/api/hp/areas/middle?largeAreaCode=Z011`）は指定された大エリアコードをHotPepper APIに渡す
- HotPepper APIは**指定された親エリアの配下のマスタデータのみ**を返す（全件取得ではない）
- 必要なデータのみを取得するため、効率的なデータフローを実現

## 変更要件

1. **初期表示時には大エリアのマスタデータのみ取得**
2. **親子関係の自動補完機能は廃止**（子エリア選択時に親を自動選択しない）
3. **大エリアを選ぶと配下エリアのマスタデータを取得し、選択可能にする**
4. **中エリアを選択したときに、その配下の小エリアマスタデータを取得する**
5. **親エリア削除時は配下の子エリアも自動削除**（現在と同じ）
6. **各エリアの複数選択上限数は変わらない**（大3件、中5件、小5件）

## 複数エリア選択時の動作

- **複数の大エリア選択時**: 各大エリアごとに個別にAPI呼び出しを行い、結果をマージ
- **複数の中エリア選択時**: 各中エリアごとに個別にAPI呼び出しを行い、結果をマージ

---

## 修正ファイル一覧

### コアロジック

1. **app/composables/useMasters.ts**
   - `useMiddleAreas`: 複数の大エリアコードに対応、SSR→CSRに変更
   - `useSmallAreas`: 複数の中エリアコードに対応、SSR→CSRに変更

2. **app/composables/useAreaSelection.ts**
   - 引数から`middleAreas`, `smallAreas`を削除
   - 内部で`useMiddleAreas`, `useSmallAreas`を呼び出し
   - 親子関係自動補完機能を削除
   - ローディング状態を返り値に追加

3. **app/pages/index.vue**
   - `useMiddleAreas`, `useSmallAreas`の呼び出しを削除
   - ローディング・エラー状態の更新

### コンポーネント

4. **app/components/SearchAreaSelector.vue**
   - Propsから`middleAreas`, `smallAreas`を削除
   - ローディング状態の表示追加

5. **app/components/SearchForm.vue**
   - Propsから`middleAreas`, `smallAreas`を削除

### テスト

6. **tests/components/SearchForm.test.ts**
   - 親子関係自動補完テストを削除
   - 段階的データ取得テストを追加

7. **tests/pages/index.test.ts**
   - `useMiddleAreas`, `useSmallAreas`のモックを削除

8. **tests/composables/useAreaSelection.test.ts**（新規作成）
   - `useAreaSelection`の単体テストを追加

### ドキュメント

9. **docs/設計/画面設計/TOPページ.md**
   - エリア選択仕様セクションを更新

---

## 詳細実装内容

### 1. useMasters.tsの修正（推奨実装：watch + キャッシュ方式）

#### useMiddleAreasの変更

**採用する実装方式**:

- `watch`で選択された大エリアコードの変更を監視
- 各大エリアごとに`$fetch`でAPIリクエストを並列実行
- 取得済みデータはMapでキャッシュし、再取得を防ぐ
- 選択が解除されたらキャッシュをクリア

```typescript
export const useMiddleAreas = (largeAreaCodes?: MaybeRef<string[]>) => {
  const codes = computed(() => unref(largeAreaCodes) ?? [])

  // すべてのデータを保持するMap（キャッシュ）
  const areaCache = ref(new Map<string, MiddleArea[]>())
  const isLoading = ref(false)
  const apiError = ref<ApiError | null>(null)

  // 各大エリアのデータを個別に取得
  const fetchAreasForCode = async (code: string) => {
    if (areaCache.value.has(code)) return // キャッシュがあればスキップ

    try {
      // 内部API呼び出し（/api/hp/areas/middle?largeAreaCode=Z011）
      // → HotPepper APIに large_area=Z011 を渡す
      // → 指定された大エリアの配下の中エリアのみを返す（全件ではない）
      const response = await $fetch<ApiSuccessResult<MiddleAreasResponse>>('/api/hp/areas/middle', {
        query: { largeAreaCode: code },
      })
      if (response.success) {
        areaCache.value.set(code, response.data.areas)
      }
    } catch (error) {
      console.error('中エリアマスタ取得エラー:', error)
      apiError.value = { code: 'FETCH_ERROR', message: 'データ取得に失敗しました' }
    }
  }

  // codesの変更を監視して必要なデータを取得
  watch(
    codes,
    async (newCodes) => {
      if (newCodes.length === 0) {
        areaCache.value.clear()
        return
      }

      isLoading.value = true
      // 各大エリアごとに並列でAPIリクエストを実行
      await Promise.all(newCodes.map((code) => fetchAreasForCode(code)))
      isLoading.value = false
    },
    { immediate: true },
  )

  // 選択された大エリアに関連する中エリアのみを返す
  const areas = computed(() => {
    const result: MiddleArea[] = []
    codes.value.forEach((code) => {
      const cached = areaCache.value.get(code)
      if (cached) result.push(...cached)
    })
    return result
  })

  return {
    areas,
    isLoading: computed(() => isLoading.value),
    apiError: computed(() => apiError.value),
    errorMessage: computed(() => apiError.value?.message ?? ''),
  }
}
```

#### useSmallAreasの変更

同様の実装パターンで、複数の中エリアコードに対応：

```typescript
export const useSmallAreas = (middleAreaCodes?: MaybeRef<string[]>) => {
  const codes = computed(() => unref(middleAreaCodes) ?? [])

  const areaCache = ref(new Map<string, SmallArea[]>())
  const isLoading = ref(false)
  const apiError = ref<ApiError | null>(null)

  const fetchAreasForCode = async (code: string) => {
    if (areaCache.value.has(code)) return

    try {
      // 内部API呼び出し（/api/hp/areas/small?middleAreaCode=Y005）
      // → HotPepper APIに middle_area=Y005 を渡す
      // → 指定された中エリアの配下の小エリアのみを返す
      const response = await $fetch<ApiSuccessResult<SmallAreasResponse>>('/api/hp/areas/small', {
        query: { middleAreaCode: code },
      })
      if (response.success) {
        areaCache.value.set(code, response.data.areas)
      }
    } catch (error) {
      console.error('小エリアマスタ取得エラー:', error)
      apiError.value = { code: 'FETCH_ERROR', message: 'データ取得に失敗しました' }
    }
  }

  watch(
    codes,
    async (newCodes) => {
      if (newCodes.length === 0) {
        areaCache.value.clear()
        return
      }

      isLoading.value = true
      await Promise.all(newCodes.map((code) => fetchAreasForCode(code)))
      isLoading.value = false
    },
    { immediate: true },
  )

  const areas = computed(() => {
    const result: SmallArea[] = []
    codes.value.forEach((code) => {
      const cached = areaCache.value.get(code)
      if (cached) result.push(...cached)
    })
    return result
  })

  return {
    areas,
    isLoading: computed(() => isLoading.value),
    apiError: computed(() => apiError.value),
    errorMessage: computed(() => apiError.value?.message ?? ''),
  }
}
```

---

### 2. useAreaSelection.tsの修正

#### 引数の変更

```typescript
export function useAreaSelection(
  largeAreas: LargeArea[],
  // middleAreas, smallAreas を削除
)
```

#### 内部でのデータ取得

```typescript
// 選択された大エリアのコード配列
const selectedLargeAreas = ref<string[]>([])
const selectedMiddleAreas = ref<string[]>([])
const selectedSmallAreas = ref<string[]>([])

// 動的データ取得
const { areas: middleAreas, isLoading: isLoadingMiddle } = useMiddleAreas(selectedLargeAreas)

const { areas: smallAreas, isLoading: isLoadingSmall } = useSmallAreas(selectedMiddleAreas)
```

#### 親子関係自動補完の削除

`addMiddleArea`と`addSmallArea`から、親エリアの自動選択処理を削除：

```typescript
const addMiddleArea = () => {
  if (middleAreaToAdd.value && selectedMiddleAreas.value.length < AREA_LIMITS.MIDDLE_AREAS) {
    selectedMiddleAreas.value = [...selectedMiddleAreas.value, middleAreaToAdd.value]
    middleAreaToAdd.value = ''
  }
}

const addSmallArea = () => {
  if (smallAreaToAdd.value && selectedSmallAreas.value.length < AREA_LIMITS.SMALL_AREAS) {
    selectedSmallAreas.value = [...selectedSmallAreas.value, smallAreaToAdd.value]
    smallAreaToAdd.value = ''
  }
}
```

#### 連鎖削除は維持

`removeLargeArea`と`removeMiddleArea`は現在のロジックを維持。

#### 返り値にローディング状態を追加

```typescript
return {
  // ... 既存の返り値
  isLoadingMiddle,
  isLoadingSmall,
}
```

---

### 3. SearchAreaSelector.vueの修正

#### Propsの変更

```typescript
const props = defineProps<{
  largeAreas: LargeArea[]
  // middleAreas, smallAreas を削除
}>()
```

#### useAreaSelectionの呼び出し

```typescript
const {
  // ... 既存の返り値
  isLoadingMiddle,
  isLoadingSmall,
} = useAreaSelection(props.largeAreas)
```

#### ローディング状態の表示

```vue
<select
  v-model="middleAreaToAdd"
  :disabled="
    selectedLargeAreas.length === 0 ||
    selectedMiddleAreas.length >= AREA_LIMITS.MIDDLE_AREAS ||
    isLoadingMiddle
  "
  @change="addMiddleArea"
>
  <option value="">
    {{ isLoadingMiddle ? '読み込み中...' : '中エリアを選択...' }}
  </option>
  <option v-for="area in availableMiddleAreas" :key="area.code" :value="area.code">
    {{ area.name }}
  </option>
</select>
```

同様に小エリアのセレクトボックスも修正。

---

### 4. SearchForm.vueの修正

Propsから`middleAreas`, `smallAreas`を削除し、テンプレートを更新：

```vue
<template>
  <SearchAreaSelector
    :large-areas="largeAreas"
    @update:selected-large-areas="selectedLargeAreas = $event"
    @update:selected-middle-areas="selectedMiddleAreas = $event"
    @update:selected-small-areas="selectedSmallAreas = $event"
  />
</template>
```

---

### 5. index.vueの修正

`useMiddleAreas`と`useSmallAreas`の呼び出しを削除：

```typescript
// 削除
// const { areas: middleAreas, ... } = useMiddleAreas()
// const { areas: smallAreas, ... } = useSmallAreas()

// 残す
const { areas: largeAreas, ... } = useLargeAreas()
const { genres, ... } = useGenres()
```

ローディング・エラー状態の更新：

```typescript
const isLoadingMasters = computed(() => isLoadingGenres.value || isLoadingLargeAreas.value)

const mastersError = computed(() => {
  return genresError.value || largeAreasError.value
})

const retryLoadMasters = async () => {
  await Promise.all([refreshGenres(), refreshLargeAreas()])
}
```

テンプレートの更新：

```vue
<SearchForm v-else :genres="genres" :large-areas="largeAreas" />
```

---

### 6. テストの更新

#### SearchForm.test.tsの修正

**削除するテスト:**

- 中エリア選択時に親の大エリアを自動選択するテスト
- 小エリア選択時に親の中・大エリアを自動選択するテスト

**追加するテスト:**

- 大エリア選択時に中エリアマスタを取得するテスト
- 中エリア選択時に小エリアマスタを取得するテスト
- ローディング状態の表示テスト
- 親エリア削除時の連鎖削除テスト

#### index.test.tsの修正

`useMiddleAreas`と`useSmallAreas`のモックを削除。

#### useAreaSelection.test.ts（新規作成）

useAreaSelectionの単体テストを作成：

- 大エリア選択時のデータ取得
- 中エリア選択時のデータ取得
- 親子関係自動補完が行われないこと
- 連鎖削除機能
- 上限チェック

---

### 7. ドキュメントの更新

**docs/設計/画面設計/TOPページ.md**のエリア選択仕様セクション（L69-74）を更新：

```markdown
#### エリア選択仕様

- 大・中・小の3階層で構成。
- タグ選択UI で表示し、選択済みのエリアはバッジ形式で表示・削除可能。
- 大エリアを選択すると、その配下の中エリアマスタを取得し選択可能になる。
- 中エリアを選択すると、その配下の小エリアマスタを取得し選択可能になる。
- 親エリアを外すと、配下の中・小エリアも自動的に解除。
- 大・中・小はそれぞれ複数選択可（上限あり：大3件/中5件/小5件）。

**データ取得タイミング:**

- 初期表示：大エリアマスタのみ取得（SSR）
- 大エリア選択時：選択された各大エリアの配下の中エリアマスタを取得（CSR、並列実行）
- 中エリア選択時：選択された各中エリアの配下の小エリアマスタを取得（CSR、並列実行）
- 親エリア削除時：配下のエリアデータもクリア
```

---

## 実装の順序

### フェーズ1: データ取得の基盤整備（useMasters.ts）

1. `useMiddleAreas`を修正して複数の大エリアコードに対応
2. `useSmallAreas`を修正して複数の中エリアコードに対応
3. 型チェック・ビルド確認

### フェーズ2: ビジネスロジックの変更（useAreaSelection.ts）

4. 引数から`middleAreas`, `smallAreas`を削除
5. 内部で`useMiddleAreas`, `useSmallAreas`を呼び出す
6. 親子関係自動補完機能を削除
7. ローディング状態を返り値に追加
8. 型チェック・ビルド確認

### フェーズ3: コンポーネントの修正

9. SearchAreaSelector.vueのProps変更とローディング表示追加
10. SearchForm.vueのProps変更
11. index.vueのデータ取得変更
12. 型チェック・Lintの確認
13. 開発サーバーで動作確認

### フェーズ4: テストの更新

14. SearchForm.test.tsの修正
15. index.test.tsの修正
16. useAreaSelection.test.tsの新規作成
17. すべてのテストが通ることを確認

### フェーズ5: ドキュメント更新と最終確認

18. TOPページ.mdの更新
19. Lint・型チェック・テストの最終確認
20. 開発サーバーでの動作確認

---

## 重要な技術的考慮事項

### Nuxt/VueのComposable制約

- Composableは`setup`関数内で同期的に呼び出す必要がある
- `watch`内で動的にAPIリクエストを発行する実装を採用
- キャッシュ機構を導入して、同じエリアの再選択時にAPIリクエストを省略

### パフォーマンス最適化

- 複数の大エリア選択時は並列にAPIリクエストを実行（`Promise.all`）
- 取得済みデータはキャッシュして再利用
- 不要なデータはキャッシュから削除（メモリ効率）

### エラーハンドリング

- 一部のAPIリクエストが失敗しても、成功したデータは表示
- エラー状態を適切にユーザーに通知

---

## クリティカルファイル

以下のファイルが最も重要な変更対象：

1. **app/composables/useMasters.ts** - データ取得ロジックの大幅変更
2. **app/composables/useAreaSelection.ts** - コアビジネスロジックの変更
3. **app/pages/index.vue** - 初期データ取得の変更
4. **app/components/SearchAreaSelector.vue** - UI/UXの調整
5. **tests/components/SearchForm.test.ts** - テストケースの大幅更新
